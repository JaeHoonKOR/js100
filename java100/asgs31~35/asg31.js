
arr[i];
/* 
인덱스 i에서 요소에 액세스하는 데 걸리는 시간은 
배열의 크기와 무관하며 배열의 크기에 관계없이 항상 동일합니다.
O(1).
*/

arr.push(5);

/* 
시간 복잡도는 배열 끝에 요소를 추가하는 데 일정한 시간이 걸리기 때문에 
O(1)입니다. 이것은 배열이 일반적으로 연속된 메모리 블록으로 구현되기 때문에 
배열의 끝에 요소를 추가하는 것은 배열의 길이 속성을 업데이트하고
사용 가능한 다음 메모리 위치에 새로운 값을 저장하는 것을 포함합니다.

그러나 최악의 경우 배열이 꽉 차서 크기를 조정해야 한다면 
전체 배열을 더 큰 새로운 메모리 블록에 복사해야 하기 때문에 
푸시()의 시간 복잡성은 O(n)가 될 수 있습니다.
*/

arr.slice();

/* 
n은 slice() 메소드를 실행할 때 복사하는 원소의 수에 해당됩니다.
따라서 slice() 메소드를 실행할 때, 새로운 배열을 생성하여 
복사하는 과정으로 만큼의 시간이 소요됩니다. O(n)
*/
arr.pop()
/* 
시간 복잡도는 O(1)입니다. 즉, pop 메서드를 실행하는 데 걸리는 시간은
배열의 크기에 관계없이 일정합니다. pop 메서드는 배열에서 
마지막 요소를 제거하고 반환하며 작업에 일정한 시간이 소요됩니다.
*/

arr.includes(5)

/* 
배열의 각 항목을 탐색하여 일치하는 항목이 있는지 확인하기 때문에,
길이가 n인 배열을 탐색하면 n번의 비교가 수행되므로
 간 복잡도는 O(n)입니다.
*/
